
# 静态链接

链接的这个过程主要解决如何将多个目标文件链接起来得到一个可执行文件

假设分别有如下的两个文件 a.c b.c

> 注意这里和书上的有点区别在于a.c中添加了 extern swap的声明

```c
extern int shared;
extern void swap(int *a, int *b);

int main() {
    int a = 100;
    swap(&a, &shared);
}
```

```c
int shared = 1;

void swap(int *a, int *b) {
    *a ^= *b = *a ^= *b;
}
```

## 空间和地址分配

我们知道可执行文件中的代码拗断和数据段都是由输入的目标文件合并起来的, 那么对于多目标文件来说, 链接器是如何将各个段合并到输出文件的呢? 或者说, 输出文件中的空间应该如何分配给输入文件?

一个简单的方法就是按次序叠加起来, 如下所示

![20230515145541](https://raw.githubusercontent.com/learner-lu/picbed/master/20230515145541.png)

但是这种方式有很严重的问题, 首先对于多个输入文件的情况会出现很多零散的段, 每一个段都有一定的地址和空间对齐要求, 对于 x86 的硬件来说段的装在地址和空间的对齐单位是 4096 字节, 也就是说即使一个段的长度只有1字节, 他也需要在内存中占据 4096 字节, 因此这并不是一个好的方案

实际上使用的方式是将各个段合并到一起, 相同性质的段组合为一个大段, 如下所示

![20230515145513](https://raw.githubusercontent.com/learner-lu/picbed/master/20230515145513.png)

### 空间地址分配的含义

前文提到了 .bss 段实际上并不占用文件的空间, 在装载时占用地址空间. 那么这里我们可以思考一个问题, **就是所谓的空间分配到底是什么空间**?

这样讲起来有点抽象, 不如举一个例子. 对于下面的代码, 全局变量中有一个 x[1000], 由于并未初始化所以它应该分配在 bss 段中

```c
int x[1000];

int main() {
    return 0;
}
```

```bash
gcc bss.c -o bss
nm bss

# 0000000000004040 B x
```

> B 对应 .bss, D 对应 .data

可以看到最后一行说明了 x 确实分配在 bss 段中, 通过 du 可以得到这个可执行文件的大小是 16KB

```bash
(base) kamilu@LZX:~/miniCRT/notes$ du -h bss
16K     bss
```

但是如果我们稍微修改一下

```c
int x[1000] = {1};

int main() {
    return 0;
}
```

此时可以看到, x 由于已经被初始化了所以被分配在 data 段中, 并且文件的体积也扩大到了 20KB, 多出来的 4KB 显然就是 x 数组的大小

```bash
$ nm bss
0000000000004020 D x
$ du -h bss
20K     bss
```

实际上地址和空间有两部分的含义, **一个是指输出在可执行文件中的空间, 第二个是装载后的虚拟地址中的虚拟地址空间**

对于有实际数据的段, 比如 .text, .data, 它们在文件中和虚拟地址中都要分配空间, 因为在二者中他们都存在

但是对于 .bss 这样的段来说**不需要在可执行文件中分配地址空间**, 只需要在虚拟地址空间中分配空间

换而言之, 无论使用 `int x[1000]` 还是 `int x[1000] = {1}`, 都确实在程序中定义了一个大小为1000的int类型的数组x, 只不过由于前面的x没有初始化, 所以不需要在可执行文件中为其开辟一块 4KB 大小的空间来存放这个数组 x 的所有值, 而是用一个记录说明符号 x, 大小 4000, 这样就可以节约可执行文件的大小了


### 手动链接

链接器一般采用**两步链接**

- **第一步 空间和地址分配**: 扫描所有输入目标文件, 获得它们每一个段的长度, 属性和位置. 将输入目标文件中的符号表中所有的符号定义和符号引用收集起来统一放到一个全局符号表中.

  在这一步中链接器能够获取所有的输入目标文件的段长度, 并且将它们合并, 计算出输出文件中各个段合并后的长度和位置, 并建立映射关系

- **第二步 符号解析与重定位**: 使用上一步收集到的信息, 读取输入文件中的段和数据以及重定位的信息, 进行符号解析与重定位, 调整代码中的地址

  实际上这一步是链接的核心, 特别是重定位

可以尝试使用 ld 将 a.o 和 b.o 链接起来, 但是这里书上有一点小问题, 首先是需要修改一下程序, 手动添加 exit, 不然程序不知道在哪里终止, 运行起来会出现 segment fault 的问题

> 参考 https://zhuanlan.zhihu.com/p/150793679
>
> https://stackoverflow.com/questions/4492799/undefined-reference-to-stack-chk-fail

```c
extern int shared;
extern void swap(int *a, int *b);

int main() {
    int a = 100;
    swap(&a, &shared);
    asm("movq $66,%rdi \n\t"
        "movq $60,%rax \n\t"
        "syscall \n\t");
}
```

其次是在编译的时候使用 `-fno-stack-protector` 关闭栈检查

```bash
gcc -fno-stack-protector -c a.c b.c
ld a.o b.o -e main -o ab
```

> -e 表示将 main 函数作为程序的入口, 默认的入口程序是 _start

可以使用 objdump 来查看 a.o b.o ab 的地址分配情况, 如下所示

```bash
(base) kamilu@LZX:~/miniCRT/notes$ objdump -h a.o

a.o:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000040  0000000000000000  0000000000000000  00000040  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  0000000000000000  0000000000000000  00000080  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  0000000000000000  0000000000000000  00000080  2**0
                  ALLOC
  3 .comment      0000002e  0000000000000000  0000000000000000  00000080  2**0
                  CONTENTS, READONLY
  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000ae  2**0
                  CONTENTS, READONLY
  5 .note.gnu.property 00000020  0000000000000000  0000000000000000  000000b0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .eh_frame     00000038  0000000000000000  0000000000000000  000000d0  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
(base) kamilu@LZX:~/miniCRT/notes$ objdump -h b.o

b.o:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000047  0000000000000000  0000000000000000  00000040  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000004  0000000000000000  0000000000000000  00000088  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  0000000000000000  0000000000000000  0000008c  2**0
                  ALLOC
  3 .comment      0000002e  0000000000000000  0000000000000000  0000008c  2**0
                  CONTENTS, READONLY
  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000ba  2**0
                  CONTENTS, READONLY
  5 .note.gnu.property 00000020  0000000000000000  0000000000000000  000000c0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .eh_frame     00000038  0000000000000000  0000000000000000  000000e0  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
(base) kamilu@LZX:~/miniCRT/notes$ objdump -h ab

ab:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .note.gnu.property 00000020  00000000004001c8  00000000004001c8  000001c8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00000087  0000000000401000  0000000000401000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .eh_frame     00000058  0000000000402000  0000000000402000  00002000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .data         00000004  0000000000404000  0000000000404000  00003000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .comment      0000002d  0000000000000000  0000000000000000  00003004  2**0
                  CONTENTS, READONLY
```

可以发现 a.o 和 b.o 的 .text 段以及 .data 段大小的和刚好是 ab 中的数值, 也印证了合并的方式

VMA(Virtual Memory Address) 代表虚拟地址, LMA(Load Memory Address)加载地址, 正常情况下这两个值应该是一样的. 但是在有的嵌入式系统中这两个值是不同的

在链接之前目标文件中的所有段的 VMA 都是0. 而链接后可执行文件中的各个段都被分配到了相应的虚拟地址, 整个程序.text段从 0x401000 开始

> [书上说代码地址总是从0x400000开始,但是查看编译好的elf头起始地址是从0开始的,这是为什么?](https://www.zhihu.com/question/552957041/answer/2738625402)

当将多个目标文件合并为一个可执行文件之后, 这时候每一个段的虚拟地址已经确定下来了, 比如 .text 段从 `0x401000` 开始, .data 段从 `0x404000` 开始. 对于每一个目标文件中的每一个符号, 它们在对应的目标文件的段中有一个固定的偏移量, 比如 X. 那么当最后得到可执行文件之后只需要对应的从 `0x401000 + X` 即可得到最终的全局符号地址

## 符号解析和重定位

使用 objdump -d 反汇编 a.o 可以得到如下程序, 其中注意到 17 处 48 8d 15 **00 00 00 00** 和 24 处的 e8 **00 00 00 00**, 分别对应 shared 的地址以及 swap 的地址. 由于在这个阶段编译器并不知道 shared 和 swap 的具体地址, 所以暂时把地址填 0

```bash
0000000000000000 <main>:
   0:   f3 0f 1e fa             endbr64
   4:   55                      push   %rbp
   5:   48 89 e5                mov    %rsp,%rbp
   8:   48 83 ec 10             sub    $0x10,%rsp
   c:   c7 45 fc 64 00 00 00    movl   $0x64,-0x4(%rbp)
  13:   48 8d 45 fc             lea    -0x4(%rbp),%rax
  17:   48 8d 15 00 00 00 00    lea    0x0(%rip),%rdx        # 1e <main+0x1e>
  1e:   48 89 d6                mov    %rdx,%rsi
  21:   48 89 c7                mov    %rax,%rdi
  24:   e8 00 00 00 00          call   29 <main+0x29>
  29:   48 c7 c7 42 00 00 00    mov    $0x42,%rdi
  30:   48 c7 c0 3c 00 00 00    mov    $0x3c,%rax
  37:   0f 05                   syscall
  39:   b8 00 00 00 00          mov    $0x0,%eax
  3e:   c9                      leave
  3f:   c3                      ret
```

对于这里的地址重定位的计算交给了链接器, 通过前面的空间和地址分配, 链接器就可以确定所有符号的虚拟地址了, 就对这些位置进行修正. 可以通过 objdump -d ab 来查看最后的可执行文件当中的代码段, 如下所示

```bash
0000000000401000 <main>:
  401000:       f3 0f 1e fa             endbr64
  401004:       55                      push   %rbp
  401005:       48 89 e5                mov    %rsp,%rbp
  401008:       48 83 ec 10             sub    $0x10,%rsp
  40100c:       c7 45 fc 64 00 00 00    movl   $0x64,-0x4(%rbp)
  401013:       48 8d 45 fc             lea    -0x4(%rbp),%rax
  401017:       48 8d 15 e2 2f 00 00    lea    0x2fe2(%rip),%rdx        # 404000 <shared>
  40101e:       48 89 d6                mov    %rdx,%rsi
  401021:       48 89 c7                mov    %rax,%rdi
  401024:       e8 17 00 00 00          call   401040 <swap>
  401029:       48 c7 c7 42 00 00 00    mov    $0x42,%rdi
  401030:       48 c7 c0 3c 00 00 00    mov    $0x3c,%rax
  401037:       0f 05                   syscall
  401039:       b8 00 00 00 00          mov    $0x0,%eax
  40103e:       c9                      leave
  40103f:       c3                      ret
```

可以注意到之前填 0 的地址已经被计算完毕

在 ELF 文件当中有一个重定位表(Relocation Table) 的结构专门用于保存这些与重定位相关的信息, 它在 ELF 文件中往往是一个或多个段. 比如 .text 如果有要被重定位的地方那么就有一个相应的叫做 .rela.text 的段(前面加上 `.rela`). 例如对于下面的段来说, 使用 `readelf -r` 查看即可得到每一个重定位表, 一共四个

```bash
Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000000000  00000040
       0000000000003bfd  0000000000000000  AX       0     0     1
  [ 2] .rela.text        RELA             0000000000000000  00005c00
       0000000000003240  0000000000000018   I      14     1     8
  [ 3] .data             PROGBITS         0000000000000000  00003c3d
       0000000000000000  0000000000000000  WA       0     0     1
  [ 4] .bss              NOBITS           0000000000000000  00003c40
       0000000000000432  0000000000000000  WA       0     0     32
  [ 5] .rodata           PROGBITS         0000000000000000  00003c40
       0000000000001210  0000000000000000   A       0     0     8
  [ 6] .rela.rodata      RELA             0000000000000000  00008e40
       0000000000000a98  0000000000000018   I      14     5     8
  [ 7] .data.rel.local   PROGBITS         0000000000000000  00004e50
       0000000000000008  0000000000000000  WA       0     0     8
  [ 8] .rela.data.r[...] RELA             0000000000000000  000098d8
       0000000000000018  0000000000000018   I      14     7     8
  [ 9] .comment          PROGBITS         0000000000000000  00004e58
       000000000000002e  0000000000000001  MS       0     0     1
  [10] .note.GNU-stack   PROGBITS         0000000000000000  00004e86
       0000000000000000  0000000000000000           0     0     1
  [11] .note.gnu.pr[...] NOTE             0000000000000000  00004e88
       0000000000000020  0000000000000000   A       0     0     8
  [12] .eh_frame         PROGBITS         0000000000000000  00004ea8
       00000000000003e8  0000000000000000   A       0     0     8
  [13] .rela.eh_frame    RELA             0000000000000000  000098f0
       00000000000002d0  0000000000000018   I      14    12     8
  [14] .symtab           SYMTAB           0000000000000000  00005290
       0000000000000660  0000000000000018          15    13     8
  [15] .strtab           STRTAB           0000000000000000  000058f0
       000000000000030b  0000000000000000           0     0     1
  [16] .shstrtab         STRTAB           0000000000000000  00009bc0
       000000000000008e  0000000000000000           0     0     1
```

```bash
Relocation section '.rela.text' at offset 0x5c00 contains 536 entries:
...
Relocation section '.rela.rodata' at offset 0x8e40 contains 113 entries:
...
Relocation section '.rela.data.rel.local' at offset 0x98d8 contains 1 entry:
...
Relocation section '.rela.eh_frame' at offset 0x98f0 contains 30 entries:
...
```

除此之外对于重定位表可以观察得到, 其 TYPE 是 RELA, Link 和 Info 分别指向对应符号表 和 需要重定位的段

```c
typedef struct {
   Elf64_Addr r_offset;
   uint64_t   r_info;
   int64_t    r_addend;
} Elf64_Rela;
```

![20230516190713](https://raw.githubusercontent.com/learner-lu/picbed/master/20230516190713.png)

输出中的 offset 对应 r_offset, r_info 的低 32 位是符号的重定位类型, 高32位是符号的在符号表中的索引, 最后的偏移量对应 r_addend

### 符号解析

在编译程序的过程中, undefined reference 是一个非常常见错误

对于一个目标文件, 我们可以看到 GLOBAL 中的三个符号中的 shared swap 都是 UND, 即 undefined 未定义类型. 

**这种未定义的符号说明了文件中有关于他们的重定位项, 如果链接器扫描了所有输入目标文件之后仍然有未定义符号就会报未定义错误**

```bash
Symbol table '.symtab' contains 6 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS a.c
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text
     3: 0000000000000000    64 FUNC    GLOBAL DEFAULT    1 main
     4: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND shared
     5: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND swap
```

接下来详细的讨论一下如何进行指令修正.

对于每一个需要重定位的符号, 其 offset 对应了其重定位的位置(主要是 .text 段), 同时还有两个重要信息分别是他们的重定位类型 `R_X86_64_PC32` 和 `R_X86_64_PLT32` , 以及最后的 Addend 的值. 如下图所示

![20230516201225](https://raw.githubusercontent.com/learner-lu/picbed/master/20230516201225.png)

那么如何在链接得到可执行文件的时候确定这个最终应该跳转的地址位置呢? 这主要取决于选址方式, 目前采取的主流重定位方式都是相对地址寻址

- R_X86_64_PC32 这种重定位类型通常用于对全局符号进行重定位,以及在指令中引用数据段中的变量时进行重定位.
- R_X86_64_PLT32 这种重定位类型通常用于对函数调用进行重定位.

首先观察下图, 前文提到过为了生成可执行文件, 首先需要做的就是取出各个目标文件的 .text, .data , .bss 段并将其分别合并为一个大段, 然后拼接到一起得到一个文件, 也就是第一步. 可以看到最终得到的可执行文件已经确定了各个段的位置, 其中 `.text` 段的起始地址是 `0x401000`, `.data` 段的起始地址是 `0x404000`, 这两个地址比较重要, 因为我们稍后会需要用到它们, 这两个段的索引分别是 2 和 4

![20230516210929](https://raw.githubusercontent.com/learner-lu/picbed/master/20230516210929.png)

观察下图, 在合并对应的段之后每一个符号的位置也就确定了下来, 其中 swap 类型为 FUNC, 地址位于 `0x401040`, 位于 2 号段(也就是 .text 段). shared 类型为 OBJECT, 地址位于 `0x404000`(也就是 .data 段的首地址), 位于 4 号段(也就是.data段). 除此之外还可以看到 main 函数, 位于 `0x401000` 也就是 .text 段的首地址.

> 不难推测, 对于其他变量和函数, 它们会在 .data 和 .text 段依次往后存放

下图中也可以比较清晰的看到 main 和 swap 函数的地址起点, 就是顺序排列下来

![20230516211039](https://raw.githubusercontent.com/learner-lu/picbed/master/20230516211039.png)

那么接下来要做的事就是如何修改这里的四个字节以找到 shared 这个变量? 这里需要做一个计算, 当执行这条指令的时候, CPU 的 ip 的位置实际上是下一条指令的开始位置, 也就是箭头所示的位置 `0x40101e`, 我们已经得到了 shared 变量的地址是 `0x404000`, 所以只需要 0x404000 - 0x40101e = 0x2fe2, 小端存储也就是图中 `e2 2f 00 00`

![20230516231522](https://raw.githubusercontent.com/learner-lu/picbed/master/20230516231522.png)

**但是请注意**, **这里实际上跳过了一步**. 在这个阶段链接器并不能直接知道它的下一条指令的地址,也就是得不到 `0x40101e` 这个值. 我们目前看到的这个值是 objdump 帮助我们反汇编显示出来的每一行代表一句汇编, 实际上这就是一坨二进制数据. 这个值的计算依赖于重定位的 offset 和 addend 计算得到, 也就是说

ADDR(shared) - (ADDR(.text) + OFFSET(shared)) + ADDEND(shared)

0x404000 - (0x401000 + 0x1a) + (-4) = 0x404000 - 0x40101e = 0x2fe2

那么接下来的过程也是同理, 需要修正 swap 的函数跳转地址, 0x401040 - 0x401029 = 0x17

> 这里的 0x401029 也是通过 (.text 段地址 + 偏移量 - addend) = 0x401000 + 0x25 - (-4) 计算得到的

![20230517004015](https://raw.githubusercontent.com/learner-lu/picbed/master/20230517004015.png)

## 静态库链接

我们可以使用如下的命令找到 Linux 下的 libc 库

```bash
(base) kamilu@LZX:~$ find /usr/lib* -name "libc.a"
/usr/lib/x86_64-linux-gnu/libc.a
/usr/lib32/libc.a
/usr/libx32/libc.a
(base) kamilu@LZX:~$ find /usr/lib* -name "libc.so"
/usr/lib/x86_64-linux-gnu/libc.so
/usr/lib32/libc.so
/usr/libx32/libc.so
```

- /usr/lib/x86_64-linux-gnu/libc.a: 这是针对64位x86架构的Linux系统的库文件.它包含了glibc库的所有符号,并且在链接时可以将所有的代码静态地链接到目标程序中.这个路径是Debian和Ubuntu系统上的默认位置.
- /usr/lib32/libc.a: 这是针对32位x86架构的Linux系统的库文件.它包含了glibc库的所有符号,并且在链接时可以将所有的代码静态地链接到目标程序中.这个路径在一些Linux系统上,如Fedora和CentOS上是默认位置.
- /usr/libx32/libc.a: 这是针对x32 ABI的64位x86架构的Linux系统的库文件.x32 ABI是一种特殊的ABI,它使用32位指针和64位寄存器,旨在提高64位计算机上32位应用程序的性能.这个路径在一些Linux系统上,如Debian和Ubuntu上是默认位置.

这些库文件是静态链接库,因此它们可能会增加可执行文件的大小,并且在多个程序使用相同的库时可能会导致重复.因此,通常建议使用动态链接库,例如libglibc.so或libc.so,以减少可执行文件的大小并实现共享.

一个静态库可以简单的看作**一组目标文件的集合**, 即很多目标文件压缩打包后形成的一个文件, 通常人们使用 ar 压缩程序将这些目标文件压缩到一起, 并且对其进行编号和索引以便于查找和检索, 这样就得到了 libc.a 这个静态库的文件

可以使用 ar 来压缩/解压/查看一个 .a 静态库的信息

```bash
ar 
```
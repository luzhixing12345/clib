
# 命令行参数解析

[xargparse.h](https://github.com/luzhixing12345/libc/blob/main/utils/xargparse.h) 是命令行解析所需的头文件, 这是一个 Head-only 的文件, 意味着您可以在主函数入口文件引用后直接使用, 但由于函数的声明的定义都写在 .h 中所以不要多次引入并参与链接

```bash
wget https://raw.githubusercontent.com/luzhixing12345/libc/main/utils/xargparse.h
```

## 快速开始

下面是一个简单且全面的使用示例

```c
#include "xargparse.h"

int main(int argc, const char **argv) {
    int i;
    char *s, *dest;
    int src;
    int *other_numbers;
    argparse_option options[] = {XBOX_ARG_BOOLEAN(NULL, [-h][--help][help = "show help information"]),
                                 XBOX_ARG_BOOLEAN(NULL, [-v][--version][help = "show version"]),
                                 XBOX_ARG_INT(&i, [-i][--input][help = "input file"]),
                                 XBOX_ARG_STR(&s, [-s][--string]),
                                 XBOX_ARG_STR_GROUP(&dest, [name = dest][help = "destination"]),
                                 XBOX_ARG_INT_GROUP(&src, [name = src][help = "source"]),
                                 XBOX_ARG_INTS_GROUP(&other_numbers, [name = "other-number"][help = "catch the other number..."]),
                                 XBOX_ARG_END()};

    XBOX_argparse parser;
    XBOX_argparse_init(&parser, options, XBOX_ARGPARSE_ENABLE_MULTI);
    XBOX_argparse_describe(&parser,
                           "ls",
                           "\nA brief description of what the program does and how it works.",
                           "\nAdditional description of the program after the description of the arguments.");
    XBOX_argparse_parse(&parser, argc, argv);

    if (XBOX_ismatch(&parser, "help")) {
        XBOX_argparse_info(&parser);
    }
    if (XBOX_ismatch(&parser, "version")) {
        printf("v0.0.1\n");
    }
    if (XBOX_ismatch(&parser, "input")) {
        printf("i = %d\n", i);
    }
    if (XBOX_ismatch(&parser, "string")) {
        printf("s = %s\n", s);
    }
    if (XBOX_ismatch(&parser, "dest")) {
        printf("dest = %s\n", dest);
    }
    if (XBOX_ismatch(&parser, "src")) {
        printf("src = %d\n", src);
    }
    int n = XBOX_ismatch(&parser, "other-number");
    for (int i = 0; i < n; i++) {
        printf("other number[%d] = %d\n", i, other_numbers[i]);
    }
    XBOX_free_argparse(&parser);
    return 0;
}
```

您可直接拷贝此代码并编译运行, 也可以在本仓库下执行 make 以得到 ./main

```bash
(base) kamilu@LZX:~/libc$ ./main --help
Usage: ls [OPTION]... [dest] [src] [other-number]...

A brief description of what the program does and how it works.

  -h   --help      show help information
  -v   --version   show version
  -i   --input     input file
  -s   --string


Additional description of the program after the description of the arguments.
```

```bash
(base) kamilu@LZX:~/libc$ ./main -v
v0.0.1
(base) kamilu@LZX:~/libc$ ./main -i
[Args Parse Error]: option [--input] needs one argument
(base) kamilu@LZX:~/libc$ ./main -i 100
i = 100
(base) kamilu@LZX:~/libc$ ./main -i 100 -s 200
i = 100
s = 200
(base) kamilu@LZX:~/libc$ ./main -i 100 -s 200 300
i = 100
s = 200
dest = 300
(base) kamilu@LZX:~/libc$ ./main -i 100 -s 200 300 400
i = 100
s = 200
dest = 300
src = 400
(base) kamilu@LZX:~/libc$ ./main -i 100 -s 200 300 "400"
i = 100
s = 200
dest = 300
src = 400
(base) kamilu@LZX:~/libc$ ./main -i 100 -s 200 "300" "400"
i = 100
s = 200
dest = 300
src = 400
(base) kamilu@LZX:~/libc$ ./main -i 100 -s 200 "300" "400" "500"
i = 100
s = 200
dest = 300
src = 400
other number[0] = 500
(base) kamilu@LZX:~/libc$ ./main -i 100 -s 200 "300" "400" abc
[Args Parse Error]: argument assign to be int but get [abc]
```

## 用法说明

以上面的示例为例, 我们需要**先定义变量然后构建一个 options 并与变量绑定**

```c
int i;
char *s, *dest;
int src;
int *other_numbers;
argparse_option options[] = {
    XBOX_ARG_BOOLEAN(NULL, [-h][--help][help = "show help information"]),
    XBOX_ARG_BOOLEAN(NULL, [-v][--version][help = "show version"]),
    XBOX_ARG_INT(&i, [-i][--input][help = "input file"]),
    XBOX_ARG_STR(&s, [-s][--string]),
    XBOX_ARG_STR_GROUP(&dest, [name = dest][help = "destination"]),
    XBOX_ARG_INT_GROUP(&src, [name = src][help = "source"]),
    XBOX_ARG_INTS_GROUP(&other_numbers, [name = "other-number"][help = "catch the other number..."]),
    XBOX_ARG_END()
};
```

### 参数绑定

以 `XBOX_ARG*` 开头的是宏, 第一个位置用于参数绑定, 后面的内容会被展开为字符串用于后续的解析

xargparse.h 一共提供了 8 种宏

- **XBOX_ARG_BOOLEAN**: 适用于单参数, 例如 `-h`, 后面不需要跟其他参数信息
- **XBOX_ARG_INT**: 表示参数接收的应该是一个 int 类型的数字, 例如 `-i 100`
- **XBOX_ARG_STR**: 表示参数接收的应该是一个 char* 类型的字符串, 例如 `-s "hello world"` `-s nihao`
- **XBOX_ARG_INT_GROUP**: 表示接收一个组, 组中**至多有**一个元素, 组的数据类型是 int
- **XBOX_ARG_INTS_GROUP**: 表示接收一个组, 组中包含若干个元素, 组的数据类型是 int
- **XBOX_ARG_STR_GROUP**: 表示接收一个组, 组中**至多有**一个元素, 组的数据类型是 char*
- **XBOX_ARG_STRS_GROUP**: 表示接收一个组, 组中包含若干个元素, 组的数据类型是 char*
- **XBOX_ARG_END**: 表示结束, 添加在 options 数组的结尾

组即不需要 `-i` `--input` 指定接收的正常参数, 以上面的例子为例, 如果命令行传参为: `./main abc 100`, 其中 "abc" 会被 dest 组接收, 100 会被 src 组接收, **需要注意的是组是有前后顺序的**

上述参数宏分别对应不同的使用场景, 您应该合理的使用和传参, **第一个位置需要绑定的参数类型与宏对应**

- `int` 对应 **XBOX_ARG_INT** 和 **XBOX_ARG_INT_GROUP**
- `char*` 对应 **XBOX_ARG_STR** 和 **XBOX_ARG_STR_GROUP**
- 对于若干参数的组来说您需要传递一个更深层次的指针
  - `int*` 对应 **XBOX_ARG_INTS_GROUP**
  - `char **` 对应 **XBOX_ARG_STRS_GROUP**
- 对于 bool 类型的参数, 您可以选择为 **XBOX_ARG_BOOLEAN** 绑定一个 NULL, 也可以绑定一个 int 类型

### 参数信息

宏的第二个参数是该参数对应的解析配置, 其完整语法如下: `[-h][--help][name=abc][help="show help information"]`, 所有配置由一对 `[]` 包裹, `[]` 内部可以有空格, `[]` 与 `[]`之间可以有空格.

> 这不是 C 的语法, 第二个参数会被宏展开为字符串, 交由函数内部处理

有 4 种合理的写法

- `[-h]`: 表示短参数 h
- `[--help]`: 表示长参数 help
- `[name=abc]`: 表示此参数命名为 abc
- `[help="some info"]`: 表示参数的帮助信息

其中需要注意如下几点

- 短参数 -h 非必须, 帮助信息(help)非必须, **长参数与name至少有一个**
- 长参数和name如果同时存在则必须相同, 即 `[--help]` `[name=help]`
- 如果只有长参数, 则name为长参数去掉 `--` 的名字, 即 `--cherry-pick` -> name 为 `cherry-pick`
- 长参数(包括--)至少 4 字节, 即 `--h` 不合法, `--ha` 合法
- 长参数默认只允许 `a-z_-` 的组合, 如果您希望使用其他字符你可手动修改其中 `check_valid_character` 函数
- 对于字符串开头结尾的 `"` 并不重要, 如果开头结尾同时存在 `"` 则会默认去掉, 即 `[help=ni hao ya]` 和 `[help="ni hao ya"]` 是等价的
- 如果帮助信息中需要输出 `[]` 符号, 在前面添加 `\\` 用于转义即可, 如 `[help="If a symbol name is truncated, do not add \[...\] suffix"]`

之后您只需要构建对象, 初始化并解析即可

```c
XBOX_argparse parser;
XBOX_argparse_init(&parser, options, 0);
XBOX_argparse_describe(&parser, "ls", "\ndescription", "\naaa.");
XBOX_argparse_parse(&parser, argc, argv);
```

其中有两点需要说明: 

`XBOX_argparse_describe` 的2 3 4位置的参数分别为 解析器的名字, 简要描述, 结尾描述

`XBOX_argparse_init` 第三个参数为 flag 标记位, 用于控制解析时的选项, 默认传 0 即可, 具体用法会在下文 解析扩展选项 中介绍

## 接收参数

`XBOX_ismatch` 函数用于判断是否接收到了参数, 并返回匹配的个数. 第二个参数是您定义的名字或长参数的名字

如果您使用的是若干参数的组, 您可以通过接收其返回值获取,如下所示

```c
if (XBOX_ismatch(&parser, "help")) {
    XBOX_argparse_info(&parser);
}
if (XBOX_ismatch(&parser, "dest")) {
    printf("dest = %s\n", dest);
}
if (XBOX_ismatch(&parser, "src")) {
    printf("src = %d\n", src);
}

int n = XBOX_ismatch(&parser, "other-number");
for (int i = 0; i < n; i++) {
    printf("other number[%d] = %d\n", i, other_numbers[i]);
}
XBOX_free_argparse(&parser);
```

xbox 提供了一个函数 `XBOX_argparse_info` 用于帮助信息的输出, 建议您在 options 中添加 -h 选项并将其绑定到 XBOX_argparse_info 函数, 用于辅助帮助信息的输出, 当然您也可以编写您自定义的 help 信息文档. 默认的帮助信息会自动为您实现对齐和说明

```bash
(base) kamilu@LZX:~/libc$ ./main --help
Usage: ls [OPTION]... [dest] [src] [other-number]...

A brief description of what the program does and how it works.

  -h   --help      show help information
  -v   --version   show version
  -i   --input     input file
  -s   --string


Additional description of the program after the description of the arguments.
```

**xargparse 使用了动态内存分配, 所以最后请注意使用 `XBOX_free_argparse` 释放内存**

接下来您利用这些参数去处理您程序真正想要完成的事情了

## 解析扩展选项

如果您希望扩展解析时选项, 您可修改 flag 标记位, 使用 `|` 运算将他们组合传入 flag

- **XBOX_ARGPARSE_IGNORE_WARNING**: 忽略警告
- **XBOX_ARGPARSE_ENABLE_STICK**: 允许参数与值粘连 `-O1 -Iinclude/`
- **XBOX_ARGPARSE_ENABLE_EQUAL**: 允许参数等号 `-i=123`
- **XBOX_ARGPARSE_ENABLE_ARG_STICK**: 允许boolean类型参数粘连 `curl -Ls xxx`, 此选项仅支持 BOOLEAN 类型的粘连传递, 请不要加入其他类型
- **XBOX_ARGPARSE_DISABLE_SORT**: 帮助信息中参数不排序, 按照默认顺序输出

> 不建议忽略警告, 但您可以在确保构建无误后使用 `XBOX_ARGPARSE_IGNORE_WARNING` 忽略所有警告信息

### 忽略警告

`XBOX_ARGPARSE_IGNORE_WARNING` : 如果启用此选项, 解析时会忽略所有危险信息, 例如

```bash
# 将下一个短参数当作解析对象
$ ./main -s -i
[Args Parse Warning]: [-i] will be passed as the argument for [-s]
s = -i

# 多个参数重复出现且未开启 XBOX_ARGPARSE_ENABLE_MULTI
$ ./main -i 100 -i 200
[Args Parse Warning]: multi argument detected for [input], covered by [200]
i = 200
```

### 参数与值粘连

`XBOX_ARGPARSE_ENABLE_STICK`: 允许参数与值粘连

正常情况下会被认为是粘连参数

```bash
$ ./main -i100
[Args Parse Error]: no match options for [-i100]
```

需要修改 flag 并重新编译

```c
XBOX_argparse_init(&parser, options, XBOX_ARGPARSE_ENABLE_STICK);
```

```bash
$ ./main -i100 -sabcd
i = 100
s = abcd
```

### 等号赋值

`XBOX_ARGPARSE_ENABLE_EQUAL`: 允许等号赋值

```c
XBOX_argparse_init(&parser, options, XBOX_ARGPARSE_ENABLE_EQUAL);
```

```bash
$ ./main -s="hello world"
s = hello world
$ ./main -s=hello
s = hello
```

允许参数与值粘连与允许等号赋值参数赋值通常一起使用, 并优先考虑 `=` 赋值, 即对于 `./main -s="hello world"` 来说, 结果是 `s = hello world` 而不是 `s = =hello world`

```c
XBOX_argparse_init(&parser, options, XBOX_ARGPARSE_ENABLE_EQUAL|XBOX_ARGPARSE_ENABLE_STICK);
```

## bool参数粘连

`XBOX_ARGPARSE_ENABLE_ARG_STICK`: 支持bool类型的参数粘连, 注意与 `XBOX_ARGPARSE_ENABLE_STICK`(选项与参数粘连) 不同

```bash
$ ./main -hv
[Args Parse Error]: Boolean argument [-h] is sticky in [-hv], do you mean XBOX_ARGPARSE_ENABLE_ARG_STICK?
```

```c
XBOX_argparse_init(&parser, options, XBOX_ARGPARSE_ENABLE_ARG_STICK);
```

```bash
$ ./main -hv
Usage: ls [OPTION]... [dest] [src] [other-number]...

A brief description of what the program does and how it works.

  -h    --help           show help information
  -i    --input          input file
  -s    --string
  -v    --version        show version


Additional description of the program after the description of the arguments.
v0.0.1
```

## 用法实例

如果您的参数解析器初始化存在问题, 或者解析过程出现错误, 程序会输出相应的错误提示信息, 并且内部会自动调用 free 释放内存, 您无需担心内存泄漏的问题

您可复制如下代码进行编译, 也可以直接运行编译得到的 kcc 可执行文件

```c
#include "xargparse.h"

char *output = NULL;
char **include_path = NULL;

char **files = NULL;
char *optimize = NULL;
char **warning = NULL;
char **library_path = NULL;
char **library_name = NULL;
char *c_standard = NULL;

int debug = 0;

int main(int argc, const char **argv) {
    argparse_option options[] = {
        XBOX_ARG_BOOLEAN(NULL, [-c][name = "compile"][help = "Compile and assemble, but do not link."]),
        XBOX_ARG_STR(&output, [-o][name = "output"][help = "Place the output into <file>."][append = " <file>"]),
        XBOX_ARG_STRS(&include_path,
                      [-I][name = "include"][append = "<dir>"]
                          [help = "Add <dir> to the end of the main include path."]),
        XBOX_ARG_STRS(
            &library_path,
            [-L][append = "<dir>"][name = "library_path"][help = "Add <dir> to the end of the main library path. "]),
        XBOX_ARG_STRS(&library_name,
                      [-l][name = "library_name"][append = "<lib>"][help = "Search <lib> in library path"]),
        XBOX_ARG_BOOLEAN(&debug, [-g][name = "debug"][help = "Generate debug information in default format."]),
        XBOX_ARG_STRS(&warning, [-W][name = "warning"][help = "Warning information option"]),
        XBOX_ARG_STR(&optimize, [-O][--optimize][help = "Set optimization level to <number>."][append = "<number>"]),
        XBOX_ARG_STR(&c_standard, [--std][help = "C Compile standard, supported: {c99}"][append="=<standard>"]),
        XBOX_ARG_BOOLEAN(NULL, [-h][--help][help = "show help information"]),
        XBOX_ARG_BOOLEAN(NULL, [-v][--version][help = "show version"]),
        XBOX_ARG_STRS_GROUP(&files, [name = "src"]),
        XBOX_ARG_END()};

    XBOX_argparse parser;
    XBOX_argparse_init(
        &parser, options, XBOX_ARGPARSE_ENABLE_ARG_STICK | XBOX_ARGPARSE_ENABLE_STICK | XBOX_ARGPARSE_ENABLE_EQUAL);
    XBOX_argparse_describe(&parser,
                           "kcc",
                           "Kamilu's C Compiler",
                           "document:   <https://github.com/luzhixing12345/kcc>\nbug report: "
                           "<https://github.com/luzhixing12345/kcc/issues>");
    XBOX_argparse_parse(&parser, argc, argv);

    if (XBOX_ismatch(&parser, "help")) {
        XBOX_argparse_info(&parser);
        XBOX_free_argparse(&parser);
        return 0;
    }

    if (XBOX_ismatch(&parser, "version")) {
        printf("%s\n", XBOX_VERSION);
        XBOX_free_argparse(&parser);
        return 0;
    }

    if (XBOX_ismatch(&parser, "compile")) {
        printf("use -c\n");
    }
    if (debug) {
        printf("use -g\n");
    }

    int n = XBOX_ismatch(&parser, "src");
    for (int i = 0; i < n; i++) {
        printf("file[%d] = [%s]\n", i, files[i]);
    }

    n = XBOX_ismatch(&parser, "include");
    for (int i = 0; i < n; i++) {
        printf("include path[%d] = [%s]\n", i, include_path[i]);
    }

    n = XBOX_ismatch(&parser, "library_path");
    for (int i = 0; i < n; i++) {
        printf("library path[%d] = [%s]\n", i, library_path[i]);
    }

    n = XBOX_ismatch(&parser, "library_name");
    for (int i = 0; i < n; i++) {
        printf("library name[%d] = [%s]\n", i, library_name[i]);
    }

    if (c_standard) {
        printf("C standard = [%s]\n", c_standard);
    }

    if (optimize) {
        printf("optimize = [%s]\n", optimize);
    }

    if (output) {
        printf("output file = [%s]\n", output);
    }
    XBOX_free_argparse(&parser);
    return 0;
}
```

kcc 提供了与 gcc 类似的参数传递方式

```bash
(base) kamilu@LZX:~/libc$ ./kcc a.c -o a
file[0] = [a.c]
output file = [a]
(base) kamilu@LZX:~/libc$ ./kcc a.c -I include1 -Iinclude2 -I=include3 -o a
file[0] = [a.c]
include path[0] = [include1]
include path[1] = [include2]
include path[2] = [include3]
output file = [a]
(base) kamilu@LZX:~/libc$ ./kcc a.c -I include1 -Iinclude2 -I=include3 -labc -l=ccc -o a
file[0] = [a.c]
include path[0] = [include1]
include path[1] = [include2]
include path[2] = [include3]
library name[0] = [abc]
library name[1] = [ccc]
output file = [a]
```

> 这对于一些 GNU 工具的实现来说很有效

### 传入的参数与int不匹配

```bash
$ ./main 123 abc
[Args Parse Error]: argument assign to be int but get [abc]

$ ./main 123 123a1
[Args Parse Error]: argument assign to be int but get [123a1]
```

### 缺少参数

```bash
$ ./main 123 -s
[Args Parse Error]: option [--string] needs one argument
```


## 参考

- [argparse](https://github.com/cofyc/argparse)
- [fflags](https://github.com/SuperH-0630/fflags)
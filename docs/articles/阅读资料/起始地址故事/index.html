<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    <link rel='stylesheet' href=../../../css/c.css /><link rel='stylesheet' href=../../../css/shell.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/luzhixing12345/libc.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">起始地址故事</a></li></ul></div><div class='markdown-body'><h1 id="h1-0">起始地址故事</h1><blockquote><p><a href="https://www.zhihu.com/question/552957041/answer/2738625402" target="_blank">书上说代码地址总是从0x400000开始,但是查看编译好的elf头起始地址是从0开始的,这是为什么?的回答</a></p></blockquote><p>其实这个是这么一个过程.</p><p>早年(8位和16位CPU时代),计算机系统是实地址模式.</p><p>那个时候,程序是直接使用物理地址.操作系统和应用程序是运行在相同的地址空间的.</p><p>由于操作系统先加载,并且不同的机器内存容量不同,所以保险起见操作系统总是加载到低地址空间(简便起见这里只讨论对于little endian的情况).而等应用程序需要加载的时候,低地址空间已经被占用,所以只能加载到更高的某一个偏移地址上.</p><p>这个偏移地址具体是多少,其实是无所谓的,只要确定就可以.</p><p>但是注意,这也意味着,所有应用程序都会被加载到同样的地址.从而任何时候只能跑一个应用程序,否则它们之间会相互覆盖.</p><p>于是有人就想,如果每次都将程序加载到内存当中不同的位置,那么不是就可以同时执行多个任务了吗?然而,简单的这样做,可执行文件当中的地址就会发生错误.因为这些地址是在程序编译链接的时候就已经决定好的.</p><p>其实在早期,计算机就是一次只能执行一个程序的.比如早期的ROM BASIC,或者早期的DOS,都是这样的单任务系统.</p><p>但是即便是是这样的单任务系统,随着要处理的数据越来越大,也出现了问题.因为8位的CPU只有256字节、16位的CPU只有64K的寻址范围,在这个范围当中要放下程序和要处理的数据,以及运行时需要的堆栈等等,这个限制很大.</p><p>为了能够使用更多的内存,CPU增加了外部地址总线的宽度.最为著名的就是8086,它内部是16位的,但是外部有20条地址总线,所以能够支持1MB的寻址范围.</p><p>但是因为寄存器都是16位的,没有办法直接存储20位的地址.所以8086采用了两个寄存器一组的方式来存储它.将一个寄存器(称为段寄存器)的值左移4位然后加上第二个寄存器(称为偏移寄存器或者指针寄存器)的值,得到一个20位的地址.</p><p>这种做法其实也就自然而然地,将整个内存空间分成了很多部分.从0地址开始,每16位的地址空间(也就是64KB)为一页,而高4位(从第17位到第20位)则代表页码.</p><p>那么,我们的应用程序如果也按照这个大小来组织,如果每段程序内所有的跳转都不超出64KB的范围,则这段程序就可以毫无修改地被放到内存上任何一页上面.无非在执行的时候,将程序当中的地址(偏移量)加上段寄存器当中的值(需左移4位),就可以得到最终的内存地址.</p><p>因此,这个时期的应用程序也对应地被分成很多个段,如text段,data段,bss段.然后每个段被分别加载到内存上的某个分页内,将各个分页的起始地址的高16位根据其中的程序段的用途被分别设置到诸如CS(代码段)、DS(数据段)、BS(堆栈段)等段寄存器当中,在需要用到地址的时候加上这些段寄存器里面的值,就可以保证程序的正常运行.</p><p>也就是,程序不再需要放在连续且固定的内存位置了.而是变得可被重定位(relocatable).并且整个程序可以使用更大的内存空间了.</p><p>这也说明,至少早在8086的时代,可执行文件当中的偏移地址,就已经和最终内存上的地址不是一个东西了,因为它并没有记录某个段具体在第几页,第几页是在被加载到内存时动态决定的.</p><p>到这里其实你的问题已经得到了回答.那就是代码在可执行文件当中的地址,原本就不一定等于实际内存当中的地址.这并非是最近才有的事情.</p><p>那么书中的0x400000又是怎么一回事情呢?</p><p>不急,我们继续往下讲.</p><p>20位的地址总线,所能提供的寻址空间,是1MB.</p><p>这对于诸如DOS/Unix等文字界面的系统是还可以的.毕竟一整个&lt;魂斗罗&gt;也就是256KB,人家还带画面.</p><p>但是命令行对于普通用户来说太不友好了.要让更多人使用计算机,更加直观的图形界面是必须的.</p><p>(那个时候对应的windows是3.X系列,基本上就需要1MB内存,而且只是DOS上套一个图形的壳,并不能称为是一个真正的操作系统)</p><p>&lt;魂斗罗&gt;这种做好就不变的,还可以用各种技巧压缩到256KB.但是对于一个系统来说,要让屏幕上每个点都可被编程,1MB的地址空间就相当不够看了.别的不说,要存下一个比较完整的汉字字库都远远不够.</p><p>所以后来32位CPU就出来了.但是在最先出来的时候,各方面软硬件还跟不上,内存也贵,大部分程序也都是16位的.所以本着能省就省的精神(毕竟牙膏厂),早期的386SX只安排了24条地址总线.</p><p>24条地址总线的寻址范围是16MB,这就是那个时代PC的顶配.对应的操作系统是win95.</p><p>当然不可能人人都是顶配.当时最为普遍的配置是386SX+4MB.很多早期的主板以及BIOS也不支持16MB,毕竟那个时候主流内存条都是1MB,你插个4条也就是4MB.win95基本上也就是按照这个规格设计的.</p><p>因此这个4MB也就自然而然成为了一个新旧时代的分水岭:win95以前的旧版程序基本上只能运行在这个4MB范围内,而如果一个程序能够从4MB这个位置开始执行,那么它基本上是一个新时代程序.</p><p>另外一方面,为了更好支持多任务,增加进程之间的隔离以及保护操作系统本身,32位CPU新增了保护模式.保护模式下,所有的进程都有自己的&quot;虚拟&quot;地址空间,从0开始的.</p><p>因为32位提供4GB的寻址范围,这在当时被认为是非常大的一个范围,所以就没有必要再将程序当中的地址拆成两个部分了.</p><p>这种模式被称为flat模式.</p><p>在flat模式下,程序又变得可以使用绝对地址(只不过是虚拟地址)了.也就是编译的时候可以将地址全部固定下来,并不需要在加载的时候进行重定位(relocate).</p><p>为了将这种flat模式的程序和之前的程序进行区别,当时的程序员选择了0x400000(4MB)这个具有纪念意义的位置.但是这其实只是一种选择,并非必须.</p><p>到这里,解释了你所说的很多书里面所说的事情.</p><p>接下来说你解析elf看到的现象,即,入口并不是0x400000的原因.</p><p>首先,如上面所说,程序的入口在地址0x400000的附近,并不是一定要这样.在flat模式下,只要放得下,它可以在任何地方.</p><p>只不过在一开始,也没有需要改变它的理由.因为这只会让事情变得更加复杂,让可执行文件的从加载到开始执行变得更慢.</p><p>但是后来发现,如果每次程序都加载到同样的位置,会使得程序的破解,或者修改,变得非常的容易.</p><p>同时,随着程序的不断变大,动态库技术开始发展.因为动态库是动态被加载进内存的(加载顺序不一定),所以无法保证每次都能加载到固定位置.</p><p>所以,之前在16位模式使用的可重定位技术就在一定程度上又回来了.程序当中的地址又变成了相对地址,需要累加某个寄存器里的值之后,才能得到最终(逻辑)地址.</p><p>最开始这项技术只是用于动态库.但是很快就有人发现,如果将其用在主程序,那么就会使得很多内存修改器,就是类似什么锁血补丁啊,什么激活码生成器啊变得难以生效.</p><p>所以,在这个时期之后的可执行文件当中的地址,又变回了相对地址的形式,而不是最终在内存当中的绝对(逻辑)地址.</p><p>那么既然调入内存要重新计算地址,在可执行文件当中程序从0开始显然计算最为简单方便.</p><p>这就是你所看到的现象.</p></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../linux/目录" >linux</a><ul><li><a href="../../linux/目录" >目录</a></li></ul><ul><li><a href="../../linux/终端" >终端</a></li></ul></li></ul><ul><li><a href="../../libc/LD_PRELOAD" >libc</a><ul><li><a href="../../libc/LD_PRELOAD" >LD_PRELOAD</a></li></ul></li></ul><ul><li><a href="../../工具库/命令行参数解析" >工具库</a><ul><li><a href="../../工具库/命令行参数解析" >命令行参数解析</a></li></ul></li></ul><ul><li><a href="../../miniCRT/ELF文件格式" >miniCRT</a><ul><li><a href="../../miniCRT/ELF文件格式" >ELF文件格式</a></li></ul><ul><li><a href="../../miniCRT/ELF文件结构详解" >ELF文件结构详解</a></li></ul><ul><li><a href="../../miniCRT/符号表" >符号表</a></li></ul><ul><li><a href="../../miniCRT/静态链接" >静态链接</a></li></ul></li></ul><ul><li><a href="../../阅读资料/起始地址故事" >阅读资料</a><ul><li><a href="../../阅读资料/起始地址故事" >起始地址故事</a></li></ul><ul><li><a href="../../阅读资料/编译器与C++" >编译器与C++</a></li></ul><ul><li><a href="../../阅读资料/交叉编译" >交叉编译</a></li></ul><ul><li><a href="../../阅读资料/AUB" >AUB</a></li></ul><ul><li><a href="../../阅读资料/gettext" >gettext</a></li></ul><ul><li><a href="../../阅读资料/gcc参数" >gcc参数</a></li></ul><ul><li><a href="../../阅读资料/函数命名规则" >函数命名规则</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../miniCRT/静态链接","../../阅读资料/编译器与C++","ab")</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png")</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png")</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>
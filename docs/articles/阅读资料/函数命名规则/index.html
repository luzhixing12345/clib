<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    <link rel='stylesheet' href=../../../css/c.css /><link rel='stylesheet' href=../../../css/shell.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/luzhixing12345/libc.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">cpp-name-mangling</a><ul><li><a href="#h2-1">Mangling basics</a><ul><li><a href="#h3-2">Global variable declaration</a></li></ul><ul><li><a href="#h3-3">Const or nested variable declaration</a></li></ul><ul><li><a href="#h3-4">Function declaration</a></li></ul><ul><li><a href="#h3-5">Function template instance declaration</a></li></ul><ul><li><a href="#h3-6">Declaration and user defined type encoding</a></li></ul><ul><li><a href="#h3-7">Substitutions</a></li></ul><ul><li><a href="#h3-8">Abbreviations</a></li></ul><ul><li><a href="#h3-9">More on substitutions in function parameters</a></li></ul><ul><li><a href="#h3-10">More on substitutions in scopes</a><ul><li><a href="#h4-11">namespace</a></li></ul><ul><li><a href="#h4-12">struct / classes</a></li></ul></li></ul><ul><li><a href="#h3-13">More on substitutions in templates</a></li></ul></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">cpp-name-mangling</h1><blockquote><p><a href="https://github.com/gchatelet/gcc_cpp_mangling_documentation" target="_blank">https://github.com/gchatelet/gcc_cpp_mangling_documentation</a></p></blockquote><p>This document gathers my findings about gcc c++ name mangling.</p><p>It is to be considered as supplementaty materials to the <a href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling" target="_blank">Itanium C++ ABI&#x27;s mangling section</a>, especially it explores what accounts as a symbol to be substituted in the case of regular functions, templates and abbreviations.</p><h2 id="h2-1">Mangling basics</h2><h3 id="h3-2">Global variable declaration</h3><p>As in <code>C</code> name mangling, it is just the name of the variable.</p><p>eg. <code>int bar;</code> is mangled as <code>bar</code>.</p><p>eg. <code>void(*baz)(int);</code> is mangled as <code>baz</code>.</p><h3 id="h3-3">Const or nested variable declaration</h3><p>eg. <code>int* const bar;</code> is mangled as <code>_ZL3bar</code></p><ul><li><code>_Z</code> preambule starts the mangled name.</li></ul><ul><li><code>L</code> indicates the variable is <code>const</code><ul><li>Only applies to types with indirections (pointer / reference) since <code>const &lt;value_type&gt;</code> is mangled as <code>&lt;value_type&gt;</code></li></ul></li></ul><ul><li><code>3bar</code> variable name, length encoded.</li></ul><p>eg. <code>void(* const baz)(int) = nullptr;</code> is mangled as <code>_ZL3baz</code></p><ul><li><code>_Z</code> preambule starts the mangled name.</li></ul><ul><li><code>L</code> indicates the variable is <code>const</code></li></ul><ul><li><code>3baz</code> variable name, length encoded.</li></ul><p>eg. <code>namespace a { int bar; }</code> is mangled as <code>_ZN1a3barE</code></p><ul><li><code>_Z</code> preambule starts the mangled name.</li></ul><ul><li><code>N1a3barE</code> encoded symbol. It is enclosed in <code>N</code>..<code>E</code> because the symbol is within a scope<ul><li><code>1a</code> namespace name, length encoded.</li></ul><ul><li><code>3bar</code> variable name, length encoded.</li></ul></li></ul><p><b>Note</b>: the <code>std</code> namespace is special. It is abbreviated <code>St</code> and remove the need for <code>N</code>..<code>E</code> enclosing.</p><p>eg. <code>namespace std { int bar; }</code> is mangled as <code>_ZSt3bar</code></p><h3 id="h3-4">Function declaration</h3><pre class="language-UNKNOWN"><code> _Z &lt;declaration&gt; (&lt;parameter&gt;+ | v )</code></pre><p><code>&lt;parameter&gt;</code> is defined as <code>([PR]K?)*(&lt;basic_type&gt;|&lt;function&gt;|&lt;user_type&gt;)</code>with:</p><ul><li><code>P</code> for pointer</li></ul><ul><li><code>R</code> for reference</li></ul><ul><li><code>K</code> for const</li></ul><ul><li><code>&lt;basic_type&gt;</code> for one of <a href="http://en.cppreference.com/w/cpp/language/types" target="_blank">C++ basic types</a></li></ul><ul><li><code>&lt;function&gt;</code> are encoded between <code>F</code>..<code>E</code>, return type of the function is encoded before parameters</li></ul><ul><li><code>&lt;user_type&gt;</code> are encoded between <code>N</code>..<code>E</code> when nested (TODO add definition) and describe the whole hierarchy of types.</li></ul><p>eg. <code>void foo()</code> is mangled as <code>_Z3foov</code></p><ul><li><code>_Z</code> preambule is always here.</li></ul><ul><li><code>3foo</code> function name, length encoded.</li></ul><ul><li><code>v</code> no parameter is encoded as a single <code>void</code> parameter.</li></ul><p><b>Note</b>: the return type is not encoded here (although there are cases where it is encoded: function pointers and funtion template instances)</p><h3 id="h3-5">Function template instance declaration</h3><pre class="language-UNKNOWN"><code> _Z &lt;declaration&gt; I&lt;template_parameter&gt;+E &lt;template_return_type&gt; (&lt;parameter&gt;+ | v )</code></pre><p>eg.</p><pre class="language-UNKNOWN"><code>template &lt;typename A&gt; void foo(A);
template &lt;&gt; void foo(int) {}</code></pre><p>is mangled <code>_Z3fooIiEvT_</code>:</p><ul><li><code>_Z</code> preambule is always here, it starts the mangled name, for OSX it would be <code>__Z</code>.</li></ul><ul><li><code>3foo</code> function name, length encoded.</li></ul><ul><li><code>IiE</code> template parameter <code>int</code> is enclosed in <code>I</code>..<code>E</code></li></ul><ul><li><code>v</code> the return type <code>void</code>.</li></ul><ul><li><code>T_</code> reference to the first template parameter. Second would be <code>T0_</code>, third <code>T1_</code>, fourth <code>T2_</code>, etc ...</li></ul><h3 id="h3-6">Declaration and user defined type encoding</h3><p>Declaration and user defined types are encoded with their scope</p><pre class="language-UNKNOWN"><code>namespace a {
    struct S {
        void foo();
        void const_foo() const;
    };
}</code></pre><ul><li><code>foo</code> is mangled <code>_ZN1a1S3fooEv</code>:<ul><li><code>N1a1S3fooE</code>: <code>a::S::foo</code>, foo is nested since it&#x27;s within <code>S</code> and <code>a</code> so it is enclosed in <code>N</code>..<code>E</code><ul><li><code>1a</code></li></ul><ul><li><code>1S</code></li></ul><ul><li><code>3foo</code></li></ul></li></ul><ul><li><code>v</code>: because there is no parameters (encoded as a single <code>void</code> parameter).</li></ul></li></ul><ul><li><code>const_foo</code> is mangled <code>_ZNK1a1S9const_fooEv</code>:<ul><li><code>NK1a1S9const_fooE</code>: <code>a::S::foo</code>, foo is nested since it&#x27;s within <code>S</code> and <code>a</code> so it is enclosed in <code>N</code>..<code>E</code><ul><li><code>K</code> because type <code>S</code> is <code>const</code> in the context of <code>foo</code></li></ul><ul><li><code>1a</code></li></ul><ul><li><code>1S</code></li></ul><ul><li><code>9const_foo</code></li></ul></li></ul></li></ul><h3 id="h3-7">Substitutions</h3><p>To save space a compression scheme is used where symbols that appears multiple times are then substituted by an item from the sequence : <code>S_</code>, <code>S0_</code>, <code>S1_</code>, <code>S2_</code>, etc ...</p><p><b>The main added value of this document is to identify what is to be counted as a substitution.</b></p><p>eg.</p><pre class="language-UNKNOWN"><code>void foo(void*, void*)</code></pre><p><code>foo</code> would be encoded as <code>_Z3fooPvS_</code>. To be decomposed as</p><ul><li><code>_Z</code></li></ul><ul><li><code>3foo</code></li></ul><ul><li><code>Pv</code> stands for &quot;pointer to void&quot;. Since it&#x27;s not a basic type it&#x27;s accounted as a symbol.</li></ul><ul><li><code>S_</code> refers to the first symbol encoded, here <code>Pv</code>.</li></ul><p><b>Note</b>: <code>foo</code> is a declaration, not a type and so it doesn&#x27;t account as a substituable symbol.</p><h3 id="h3-8">Abbreviations</h3><p>Some symbols are recognized as special and are never substituted</p><pre class="language-UNKNOWN"><code>St = ::std::
Sa = ::std::allocator
Sb = ::std::basic_string
Ss = ::std::basic_string&lt;char, ::std::char_traits&lt;char&gt;, ::std::allocator&lt;char&gt; &gt;
Si = ::std::basic_istream&lt;char, ::std::char_traits&lt;char&gt; &gt;
So = ::std::basic_ostream&lt;char, ::std::char_traits&lt;char&gt; &gt;
Sd = ::std::basic_iostream&lt;char, ::std::char_traits&lt;char&gt; &gt;</code></pre><h3 id="h3-9">More on substitutions in function parameters</h3><p>Function parameters are either basic types, user defined types or indirections to basic or user defined types.</p><ul><li>Basic types are encoded using a single letter. See <a href="https://mentorembedded.github.io/cxx-abi/abi.html#mangling-type" target="_blank">Itanium C++ ABI&#x27;s types mangling</a>. Basic types are never substituable.<ul><li>eg. <code>void foo(int)</code> is encoded <code>_Z3fooi</code></li></ul></li></ul><ul><li>No parameter is seen by the compiler as a single <code>void</code> parameter.<ul><li>eg. <code>void foo()</code> is seen as <code>void foo(void)</code> and encoded <code>_Z3foov</code></li></ul></li></ul><ul><li>Parameters are encoded one after the other.<ul><li>eg. <code>void foo(char, int, short)</code> is encoded <code>_Z3foocis</code>. None of <code>char</code>, <code>int</code> or <code>short</code> are substituable.</li></ul></li></ul><hr><ul><li>Indirections (pointer/reference) and type qualifiers are prepended to the type. Each indirection / type qualifier accounts for a new symbol.<ul><li>eg. <code>void foo(int)</code> is encoded <code>_Z3fooi</code>.<ul><li>No substitution.</li></ul></li></ul><ul><li>eg. <code>void foo(const int)</code> is encoded <code>_Z3fooi</code>.<ul><li>No substitution.</li></ul></li></ul><ul><li>eg. <code>void foo(const int*)</code> is encoded <code>_Z3fooPKi</code><ul><li><code>Ki</code> becomes <code>S_</code></li></ul><ul><li><code>PKi</code> becomes <code>S0_</code></li></ul></li></ul><ul><li>eg. <code>void foo(const int&amp;)</code> is encoded <code>_Z3fooRKi</code><ul><li><code>Ki</code> becomes <code>S_</code></li></ul><ul><li><code>RKi</code> becomes <code>S0_</code></li></ul></li></ul><ul><li>eg. <code>void foo(const int* const*)</code> is encoded <code>_Z3fooPKPKi</code><ul><li><code>Ki</code> becomes <code>S_</code></li></ul><ul><li><code>PKi</code> becomes <code>S0_</code></li></ul><ul><li><code>KPKi</code> becomes <code>S1_</code></li></ul><ul><li><code>PKPKi</code> becomes <code>S2_</code></li></ul></li></ul><ul><li>eg. <code>void foo(int*&amp;)</code> is encoded <code>_Z3fooRPi</code><ul><li><code>Pi</code> becomes <code>S_</code></li></ul><ul><li><code>RPi</code> becomes <code>S0_</code></li></ul></li></ul></li></ul><p><b>Note</b>: <code>const int</code> alone is encoded as <code>int</code>, more generally constness of the type is not part of the signature (but constness of indirect types are).</p><hr><ul><li>Functions are encoded between <code>F</code>..<code>E</code> and prepended with <code>P</code> for function pointer (<code>R</code> for function reference), return type of the function is encoded.<ul><li>eg. <code>void foo(void(*)(int))</code> is encoded <code>_Z3fooPFviE</code><ul><li><code>FviE</code> becomes <code>S_</code></li></ul><ul><li><code>PFviE</code> becomes <code>S0_</code></li></ul><ul><li>eg. <code>void foo(void*(*)(void*),void*(*)(const void*),const void*(*)(void*));</code> is encoded <code>_Z3fooPFPvS_EPFS_PKvEPFS3_S_E</code> with the following substitutions</li></ul></li></ul></li></ul><pre class="language-UNKNOWN"><code>    _Z3fooPFPvS_EPFS_PKvEPFS3_S_E
S_          ^^                    : Pv          void*
S0_        ^^^^^^                 : FPvS_E      void*()(void*)
S1_       ^^^^^^^                 : PFPvS_E     void*(*)(void*)
S2_                   ^^          : Kv          const void
S3_                  ^^^          : PKv         const void*
S4_               ^^^^^^^         : FS_PKvE     void*()(const void*)
S5_              ^^^^^^^^         : PFS_PKvE    void*(*)(const void*)
S6_                       ^^^^^^^ : FS3_S_E     const void*()(void*)
S7_                      ^^^^^^^^ : PFS3_S_E    const void*(*)(void*)</code></pre><h3 id="h3-10">More on substitutions in scopes</h3><h4 id="h4-11">namespace</h4><pre class="language-UNKNOWN"><code>namespace a {
    struct A{};
    void foo(A) {}
}</code></pre><p><code>foo</code> would be encoded as <code>_ZN1a3fooENS_1AE</code></p><ul><li><code>a::foo</code> is encoded as <code>N1a3fooE</code><ul><li>It is enclosed by <code>N</code>..<code>E</code> (symbol is nested and not in <code>std</code>)</li></ul><ul><li><code>a</code> is encoded <code>1a</code></li></ul><ul><li><code>foo</code> is encoded <code>3foo</code></li></ul></li></ul><ul><li><code>a::A</code> is encoded <code>NS_1AE</code><ul><li>enclosed in <code>N</code>..<code>E</code> (symbol is nested and not in <code>std</code>)</li></ul><ul><li><code>a</code> is encoded <code>S_</code></li></ul><ul><li><code>A</code> is encoded <code>1A</code></li></ul></li></ul><hr><p><b>Note</b>: if namespace is <code>std</code> then it is abbreviated and nested symbol are no more enclosed in <code>N</code>..<code>E</code></p><pre class="language-UNKNOWN"><code>namespace std {
    struct A{};
    void foo(A) {}
}</code></pre><p><code>foo</code> is encoded as <code>_ZSt3fooSt1A</code></p><ul><li><code>std::foo</code> is encoded as <code>St3foo</code></li></ul><ul><li><code>std::A</code> is encoded as <code>St1A</code></li></ul><p><b>Note</b>: <code>std</code> is not substituted since it is an abbreviation.</p><h4 id="h4-12">struct / classes</h4><pre class="language-UNKNOWN"><code>struct A {
    struct B{};
    void foo(B);
};</code></pre><p><code>void A::foo(A::B)</code> is encoded <code>_ZN1A3fooENS_1BE</code></p><ul><li><code>N1A3fooE</code>: declaration<ul><li><code>1A</code>: <code>A</code> is now as <code>S_</code></li></ul><ul><li><code>3foo</code>: name (not substituable)</li></ul></li></ul><ul><li><code>NS_1BE</code>: single parameter of type <code>B</code><ul><li><code>S_</code>: <code>A</code></li></ul><ul><li><code>1B</code>: name, <code>B</code> is now <code>S0_</code></li></ul></li></ul><h3 id="h3-13">More on substitutions in templates</h3><p>Template instances account for one substitution.</p><pre class="language-UNKNOWN"><code>template&lt;typename T&gt;
struct A {
    void foo(A);
};

template&lt;&gt; void A&lt;int&gt;::foo(A&lt;int&gt;) {}</code></pre><p><code>template&lt;&gt; void A&lt;int&gt;::foo(A&lt;int&gt;)</code> is encoded as <code>_ZN1AIiE3fooES0_</code></p><ul><li><code>N1AIiE3fooE</code>: declaration<ul><li><code>1AIiE</code>: is the template instantiation<ul><li><code>1A</code>: is now <code>S_</code></li></ul><ul><li><code>IiE</code>: one <code>int</code> template parameter</li></ul><ul><li>It accounts for a substitution, it is now <code>S0_</code></li></ul></li></ul><ul><li><code>3foo</code>: name (not substituable)</li></ul></li></ul><ul><li><code>S0_</code>: refers to <code>A&lt;int&gt;</code></li></ul><hr><p>Templated function parameters are substituted with <code>T[0-9]*_</code> on first use and then substituted again normally.</p><pre class="language-UNKNOWN"><code>struct A {
    template&lt;typename T&gt;
    void foo(T, T);
};

template&lt;&gt; void A::foo&lt;int&gt;(int, int) {}</code></pre><p><code>template&lt;&gt; void A::foo&lt;int&gt;(int, int)</code> is encoded as <code>_ZN1A3fooIiEEvT_S1_</code></p><ul><li><code>N1A3fooIiEE</code>: declaration<ul><li><code>1A</code>: is now <code>S_</code></li></ul><ul><li><code>3foo</code>: name (not substituable)</li></ul><ul><li><code>IiE</code>: one <code>int</code> template parameter, is now <code>T_</code></li></ul><ul><li><code>N1A3fooIiEE</code> the full instantiated template is now <code>S0_</code></li></ul></li></ul><ul><li><code>v</code>: template instance return type</li></ul><ul><li><code>T_S1_</code> function parameters<ul><li><code>T_</code>: refers to the first template parameter, is now <code>S1_</code></li></ul><ul><li><code>S1_</code></li></ul></li></ul><hr><p>Templated function parameters are substituted only if the declaration is templated.</p><pre class="language-UNKNOWN"><code>template&lt;typename T&gt;
struct A {
    void foo(T, T);
};

template&lt;&gt; void A&lt;int&gt;::foo(int, int) {}</code></pre><p><code>template&lt;&gt; void A&lt;int&gt;::foo(int, int)</code> is encoded as <code>_ZN1AIiE3fooEii</code></p><ul><li><code>N1AIiE3fooE</code>: declaration<ul><li><code>1A</code>: is now <code>S_</code></li></ul><ul><li><code>IiE</code>: one <code>int</code> template parameter (basic types are not substituable)</li></ul><ul><li><code>1AIiE3</code>: is now <code>S0_</code></li></ul><ul><li><code>3foo</code>: name (not substituable)</li></ul></li></ul><ul><li><code>ii</code>: first and second parameter refers to the first template parameter but is not substituted.</li></ul><hr><pre class="language-UNKNOWN"><code>struct B {};

template&lt;typename T&gt;
struct A {
    void foo(T, T);
};

template &lt;&gt; void A&lt;B&gt;::foo(B, B) {}</code></pre><p><code>template &lt;&gt; void A&lt;B&gt;::foo(B, B)</code> is encoded as <code>_ZN1AI1BE3fooES0_S0_</code></p><ul><li><code>N1AI1BE3fooE</code>: declaration<ul><li><code>1A</code>: is now <code>S_</code></li></ul><ul><li><code>I1BE</code>: one <code>B</code> template parameter is now <code>S0_</code></li></ul><ul><li><code>1AI1BE</code>: is now <code>S1_</code></li></ul><ul><li><code>3foo</code>: name (not substituable)</li></ul></li></ul><ul><li><code>S0_S0_</code>: <code>S0_</code> refers to <code>B</code>.</li></ul><hr><p>Function template parameters are substituted.</p><pre class="language-UNKNOWN"><code>template&lt;typename A, typename B&gt; A foo(B, A, B);
template&lt;&gt; int foo(char, int, char) {}
template&lt;&gt; int foo(int, int, int) {}</code></pre><p><code>template&lt;&gt; int foo(char, int, char)</code> is encoded as <code>_Z3fooIicET_T0_S0_S1_</code></p><ul><li><code>3fooIicE</code>: is now <code>S_</code></li></ul><ul><li><code>T_</code>: The return type of the function. <code>int</code> is now <code>S0_</code></li></ul><ul><li><code>T0_</code>: <code>char</code> is now <code>S1_</code></li></ul><p><code>template&lt;&gt; int foo(int, int, int)</code> is encoded as <code>_Z3fooIiiET_T0_S0_S1_</code></p><ul><li><code>3fooIiiE</code>: is now <code>S_</code></li></ul><ul><li><code>T_</code>: The return type of the function. <code>int</code> is now <code>S0_</code></li></ul><ul><li><code>T0_</code>: <code>int</code> is now <code>S1_</code></li></ul></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../linux/目录" >linux</a><ul><li><a href="../../linux/目录" >目录</a></li></ul><ul><li><a href="../../linux/终端" >终端</a></li></ul></li></ul><ul><li><a href="../../libc/LD_PRELOAD" >libc</a><ul><li><a href="../../libc/LD_PRELOAD" >LD_PRELOAD</a></li></ul></li></ul><ul><li><a href="../../工具库/命令行参数解析" >工具库</a><ul><li><a href="../../工具库/命令行参数解析" >命令行参数解析</a></li></ul></li></ul><ul><li><a href="../../miniCRT/ELF文件格式" >miniCRT</a><ul><li><a href="../../miniCRT/ELF文件格式" >ELF文件格式</a></li></ul><ul><li><a href="../../miniCRT/ELF文件结构详解" >ELF文件结构详解</a></li></ul><ul><li><a href="../../miniCRT/符号表" >符号表</a></li></ul><ul><li><a href="../../miniCRT/静态链接" >静态链接</a></li></ul></li></ul><ul><li><a href="../../阅读资料/起始地址故事" >阅读资料</a><ul><li><a href="../../阅读资料/起始地址故事" >起始地址故事</a></li></ul><ul><li><a href="../../阅读资料/编译器与C++" >编译器与C++</a></li></ul><ul><li><a href="../../阅读资料/交叉编译" >交叉编译</a></li></ul><ul><li><a href="../../阅读资料/AUB" >AUB</a></li></ul><ul><li><a href="../../阅读资料/gettext" >gettext</a></li></ul><ul><li><a href="../../阅读资料/gcc参数" >gcc参数</a></li></ul><ul><li><a href="../../阅读资料/函数命名规则" >函数命名规则</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../阅读资料/gcc参数",".","ab")</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png")</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png")</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>